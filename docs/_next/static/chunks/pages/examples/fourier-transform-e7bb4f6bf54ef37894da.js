(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[514],{5346:function(e,n,r){"use strict";var t=r(5893);n.Z=function(e){var n=e.src;return(0,t.jsx)("div",{style:{position:"relative",paddingBottom:"56.25%"},children:(0,t.jsx)("iframe",{src:n,width:"100%",height:"100%",style:{width:"100%",height:"100%",position:"absolute",left:0,top:0},frameBorder:"0"})})}},2802:function(e,n,r){"use strict";var t=r(5893);n.Z={github:"https://github.com/manim-web/manim-web",docsRepositoryBase:"https://github.com/manim-web/manim-web.github.io/blob/master",titleSuffix:" - Manim Web",nextLinks:!0,prevLinks:!0,search:!0,customSearch:null,darkMode:!0,footer:!0,footerText:"MIT ".concat((new Date).getFullYear()," \xa9 Hugo SALOU."),footerEditLink:"Edit this page on GitHub",logo:(0,t.jsx)("span",{children:"Manim Web: Mathematical Animation Engine, for the web"}),head:(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1.0"}),(0,t.jsx)("meta",{name:"description",content:"Manim Web: Mathematical Animation Engine, for the web"}),(0,t.jsx)("meta",{name:"og:title",content:"Manim Web: Mathematical Animation Engine, for the web"}),(0,t.jsx)("meta",{name:"google-site-verification",content:"J7lM49tFJ8e1d0Qte2uweuO9VkJgRIJ0SKyg89qfO-A"})]})}},6800:function(e,n,r){"use strict";r.r(n);var t=r(5893),a=r(7829),o=r.n(a),i=r(3805),c=r(2802),l=r(5346),s=function(e){return(0,i.withSSG)(o()({filename:"fourier-transform.mdx",route:"/examples/fourier-transform",meta:{},pageMap:[{name:"api-reference",route:"/api-reference"},{name:"blog",children:[{name:"2022-goals",route:"/blog/2022-goals"},{name:"meta.json",meta:{"2022-goals":"Goals for 2022"}}],route:"/blog"},{name:"examples",children:[{name:"fourier-transform",route:"/examples/fourier-transform"},{name:"index",route:"/examples"},{name:"logo",route:"/examples/logo"},{name:"matrix-transformation",route:"/examples/matrix-transformation"},{name:"meta.json",meta:{index:"All examples","square-to-circle":"Square to Circle","complex-exponential":"Complex Exponential","fourier-transform":"Fourier Transform",logo:"Logo","matrix-transformation":"Matrix Transformation"}},{name:"square-to-circle",route:"/examples/square-to-circle"}],route:"/examples"},{name:"getting-started",route:"/getting-started"},{name:"index",route:"/"},{name:"meta.json",meta:{index:"Introduction","getting-started":"Getting Started","api-reference":"API Reference",examples:"Examples"}}]},c.Z))(e)};n.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return s?(0,t.jsx)(s,Object.assign({},e,{children:(0,t.jsx)(n,{})})):n();function n(){var n=Object.assign({h1:"h1",p:"p",pre:"pre",code:"code"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"Fourier Transform example"}),"\n",(0,t.jsx)(n.p,{children:"This animation is interactive.\nWhen the fourier graph has been created, you can drag the red dot to change\nthe winding frequency."}),"\n",(0,t.jsx)(l.Z,{src:"/example/fourier_transform.html"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"import 'package:manim_web/manim.dart';\n\nconst resolution = 3;\n\nclass FourierScene extends Scene {\n  late Axes timeAxes;\n  late Axes frequencyAxes;\n  late NumberPlane circlePlane;\n  late DashedVMobject dashedCircle;\n  late SurroundingRectangle frequencyBox;\n  late Dot centerOfMass;\n  late Dot fourierDot;\n  late FunctionGraph fourierGraph;\n  late FunctionGraph wave;\n  late ParametricFunction polarized;\n  late VMobject partialFourierGraph;\n\n  double windingFrequency = 0;\n\n  @override\n  FutureOr<void> preload() {\n    MathTex.preload(r'\\hat{g}(f) = \\int^{+\\infty}_{-\\infty} g(t)'\n        r' e^{-2 \\pi ift} dt');\n  }\n\n  @override\n  Future construct() async {\n    await addWaveWithAxes();\n    windingFrequency = 5;\n    await addPolarizedWaveWithAxes();\n\n    addFrequencyAxes();\n    await playMany([FadeIn(frequencyAxes), FadeIn(frequencyBox)]);\n    fourierGraph = getFourierGraph(wave);\n\n    await addDots();\n    await showFourierGraphCreation();\n    await addFormula();\n\n    makeInteractive();\n\n    await continueRendering();\n  }\n\n  Future addFormula() async {\n    var tex = MathTex(r'\\hat{g}(f) = \\int^{+\\infty}_{-\\infty} g(t)'\n        r' e^{-2 \\pi ift} dt')\n      ..toCorner(corner: UR)\n      ..scaleUniformly(1.2);\n    await play(ShowCreation(tex));\n  }\n\n  Future addAllAxes() async {\n    addCirclePlane();\n    addFrequencyAxes();\n    await play(FadeIn(circlePlane));\n    await play(FadeIn(frequencyAxes));\n  }\n\n  Future addDots() async {\n    partialFourierGraph = VMobject()\n      ..setFill(color: TRANSPARENT)\n      ..setPoints([fourierGraph.getEnd()]);\n    centerOfMass = Dot(ORIGIN)..setColor(color: RED_C);\n    fourierDot = Dot(fourierGraph.getEnd())..setColor(color: RED_C);\n\n    centerOfMass\n        .addUpdater((dot, dt) => dot..moveToPoint(polarized.getCenterOfMass()));\n\n    await play(FadeIn(centerOfMass));\n    await play(FadeIn(fourierDot));\n\n    fourierDot.addUpdater(fourierDotCreationUpdater);\n  }\n\n  Mobject fourierDotCreationUpdater(Mobject dot, double dt) =>\n      dot..moveToPoint(partialFourierGraph.getStart());\n\n  Future showFourierGraphCreation() async {\n    addToFront([fourierDot, partialFourierGraph]);\n\n    partialFourierGraph.addUpdater((graph, dt) =>\n        graph..pointwiseBecomePartial(fourierGraph, windingFrequency / 5, 1));\n\n    await play(getFrequencyChangeAnimation(wave, polarized, 5, 2, runTime: 12));\n    await play(getFrequencyChangeAnimation(wave, polarized, 2, 0, runTime: 10));\n\n    remove([partialFourierGraph]);\n    add([fourierGraph]);\n  }\n\n  Future addWaveWithAxes() async {\n    addTimeAxes();\n    // wave = getCosineWave(shiftVal: 0, scaleVal: 1.8); // positive and negative\n    wave = getCosineWave(); // positive only\n    await play(FadeIn(timeAxes));\n    await play(ShowCreation(wave));\n  }\n\n  Future addPolarizedWaveWithAxes() async {\n    addCirclePlane();\n    var polarizedTarget = getPolarizedMobject(wave, windingFrequency);\n    polarized = wave.copy();\n    await play(FadeIn(circlePlane));\n    await play(Transform(polarized, target: polarizedTarget));\n  }\n\n  void makeInteractive() {\n    fourierDot.removeUpdater(fourierDotCreationUpdater);\n\n    var draggableDot = DraggableMobject(mob: fourierDot);\n    draggableDot.addUpdater(draggableDotOnFunctionUpdater);\n\n    add([draggableDot]);\n  }\n\n  Mobject draggableDotOnFunctionUpdater(Mobject dot, double dt) {\n    var coords = frequencyAxes.pointToCoords(fourierDot.getPos());\n    var x = clip(coords.x, 0, 5).toDouble();\n    var y = fourierGraph.getValueFromFunction(x);\n    var pt = frequencyAxes.c2p(Vector3(x, y, 0));\n    fourierDot.moveToPoint(pt);\n\n    windingFrequency = x;\n    polarized.become(getPolarizedMobject(wave, x));\n\n    return dot;\n  }\n\n  FunctionGraph getFourierGraph(FunctionGraph wave) {\n    return frequencyAxes.getGraph((x) => getFourierTransform(x, wave).real,\n        stepSize: 0.05 / resolution);\n  }\n\n  Complex getFourierTransform(double x, ParametricFunction wave,\n      {bool useAlmostFourierTransform = true}) {\n    var anchors = wave.getAnchors();\n\n    var _polarizePoint = (Vector3 pt, double freq) {\n      var coords = timeAxes.pointToCoords(pt);\n\n      var t = coords.x;\n      var y = coords.y;\n\n      var z = Complex.exp(angle: -TAU * freq * t) * Complex.fromDouble(y);\n\n      return z;\n    };\n\n    var polarizedPoints = [for (var pt in anchors) _polarizePoint(pt, x)];\n\n    // TODO When the fft function will be working properly, use the code bellow\n    // var coords = [for (var pt in anchors) timeAxes.p2c(pt)];\n    // var values = [for (var c in coords) c.y];\n\n    // var polarizedPoints = fft(values);\n\n    var scalar = Complex.fromDouble(\n        useAlmostFourierTransform ? 1 / polarizedPoints.length : 1);\n\n    return polarizedPoints.reduce((a, b) => a + b) * scalar;\n  }\n\n  Axes addTimeAxes() {\n    timeAxes = Axes(\n      xMin: 0,\n      xMax: 4.4,\n      yMin: -1,\n      yMax: 2.5,\n      xAxisConfig: AxisConfig(\n        tickFrequency: 0.25,\n        numbersWithElongatedTicks: [0, 1, 2, 3, 4],\n        unitSize: 2,\n      ),\n      yAxisConfig: AxisConfig(\n        unitSize: 0.5,\n        numbersWithElongatedTicks: [],\n      ),\n      axisConfig: AxisConfig(\n        includeTip: true,\n      ),\n    )\n      ..setColor(color: LIGHT_GREY)\n      ..toCorner(corner: UL);\n\n    // TODO Add labels\n\n    return timeAxes;\n  }\n\n  NumberPlane addCirclePlane() {\n    circlePlane = NumberPlane(xMin: -2.1, yMin: -2.1, yMax: 2.1, xMax: 2.1)\n      ..scaleUniformly(0.8)\n      ..toCorner(corner: DL);\n\n    dashedCircle = Circle().getDashed(numDashes: 50)\n      ..setStroke(width: DEFAULT_STROKE_WIDTH / 2)\n      ..scaleUniformly(0.8)\n      ..shift(circlePlane.coordsToPoint(ORIGIN));\n\n    circlePlane.addToFront([dashedCircle]);\n\n    return circlePlane;\n  }\n\n  Axes addFrequencyAxes() {\n    frequencyAxes = Axes(\n      axisConfig: AxisConfig(color: TEAL_C),\n      xMin: 0,\n      xMax: 5,\n      xAxisConfig:\n          AxisConfig(unitSize: 1, numbersToShow: range(start: 1, end: 6)),\n      yMin: -1,\n      yMax: 1,\n      yAxisConfig:\n          AxisConfig(unitSize: 1.4, tickFrequency: 0.5, labelDirection: LEFT),\n    )..setColor(color: TEAL_C);\n\n    frequencyAxes.nextToMobject(circlePlane, direction: RIGHT);\n    frequencyBox =\n        SurroundingRectangle(mobject: frequencyAxes, buff: MED_SMALL_BUFFER)\n          ..setStroke(color: TEAL_C);\n\n    // TODO add labels\n\n    return frequencyAxes;\n  }\n\n  FunctionGraph getTimeGraph(double Function(double) func,\n      [double stepSize = 0.05 / resolution]) {\n    return timeAxes.getGraph(func, stepSize: stepSize)\n      ..setStroke(color: YELLOW_C)\n      ..setFill(color: TRANSPARENT);\n  }\n\n  FunctionGraph getCosineWave(\n          {List<double> frequencies = const [2],\n          double shiftVal = 1,\n          double scaleVal = 0.9,\n          double stepSize = 0.05 / resolution}) =>\n      getTimeGraph(\n          (t) =>\n              shiftVal +\n              scaleVal *\n                  sum([for (var freq in frequencies) cos(TAU * t * freq)]),\n          stepSize);\n\n  Mobject getPolarizedMobject(Mobject mob, double windingFrequency) {\n    var polarizedMobject = mob.copy();\n    polarizedMobject.applyFunction((pt) => polarizePoint(pt, windingFrequency));\n    return polarizedMobject;\n  }\n\n  Vector3 polarizePoint(Vector3 pt, double windingFrequency) {\n    var coords = timeAxes.pointToCoords(pt);\n\n    var t = coords.x;\n    var y = coords.y;\n\n    var z =\n        Complex.exp(angle: -TAU * windingFrequency * t) * Complex.fromDouble(y);\n\n    return circlePlane.coordsToPoint(z.toVector3());\n  }\n\n  UpdateFromFunc getPolarizedAnimation(\n      Mobject mobject, double windingFrequency) {\n    var polarized = getPolarizedMobject(mobject, windingFrequency);\n\n    return UpdateFromFunc(\n        mobject: polarized,\n        updateFunc: (mob) {\n          Transform(mob, target: getPolarizedMobject(mobject, windingFrequency))\n              .update(1);\n          return mob;\n        });\n  }\n\n  Future animateFrequencyChange(List<Tuple2<Mobject, Mobject>> mobjects,\n      double startWindingFrequency, double newWindingFrequency,\n      {double runTime = 3, List<Animation> addedAnimations = const []}) async {\n    await playMany([\n      for (var mob in mobjects)\n        getFrequencyChangeAnimation(\n            mob.item1, mob.item2, startWindingFrequency, newWindingFrequency),\n      ...addedAnimations\n    ]);\n  }\n\n  UpdateFromAlphaFunc getFrequencyChangeAnimation(\n      Mobject mobject,\n      Mobject polarized,\n      double startWindingFrequency,\n      double newWindingFrequency,\n      {double runTime = 3}) {\n    return UpdateFromAlphaFunc(\n        mobject: polarized,\n        updateFunc: (pm, alpha) {\n          var freq =\n              interpolate(startWindingFrequency, newWindingFrequency, alpha);\n          windingFrequency = freq;\n\n          var newPm = getPolarizedMobject(mobject, freq);\n\n          pm.become(newPm);\n\n          return pm;\n        },\n        runTime: runTime);\n  }\n}\n"})})]})}}},5809:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/examples/fourier-transform",function(){return r(6800)}])}},function(e){e.O(0,[511,774,888,179],(function(){return n=5809,e(e.s=n);var n}));var n=e.O();_N_E=n}]);